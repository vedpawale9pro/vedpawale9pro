<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cloud Practical — Basic Test Page</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin: 20px; line-height: 1.45; color: #111; }
    h1 { font-size: 1.6rem; margin-bottom: .2rem; }
    .card { border: 1px solid #ddd; padding: 12px; margin: 10px 0; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,.04); }
    label { display:block; margin-top:8px; font-weight:600; }
    input[type="text"], input[type="url"], textarea { width:100%; padding:8px; margin-top:6px; box-sizing:border-box; border-radius:6px; border:1px solid #ccc; }
    button { margin-top:10px; padding:8px 12px; border-radius:6px; border: none; cursor:pointer; background:#0366d6; color:#fff; }
    pre { background:#f6f8fa; padding:8px; border-radius:6px; overflow:auto; }
    .result { padding:8px; margin-top:8px; border-radius:6px; background:#fff; border:1px dashed #eee; }
    small.note { color:#666; display:block; margin-top:6px; }
  </style>
</head>
<body>
  <h1>Cloud Practical — Basic Test Page</h1>
  <p>Use the controls below to test endpoints and basic network behaviors. Replace sample endpoints with your cloud URLs before running tests.</p>

  <div class="card">
    <h2>1) HTTP Latency (RTT)</h2>
    <label>URL to ping (GET):</label>
    <input id="pingUrl" type="url" value="https://httpbin.org/get" />
    <button id="pingBtn">Run 5 RTT measurements</button>
    <div id="pingResults" class="result">No results yet.</div>
    <small class="note">This measures round-trip time using fetch (includes server processing + network).</small>
  </div>

  <div class="card">
    <h2>2) Download Speed</h2>
    <label>File URL to download (provide a reasonably large file for a better test):</label>
    <input id="downloadUrl" type="url" value="https://speed.hetzner.de/100MB.bin" />
    <label>Bytes to read from response (max):</label>
    <input id="downloadBytes" type="text" value="5000000" />
    <button id="downloadBtn">Run download test</button>
    <div id="downloadResults" class="result">No results yet.</div>
    <small class="note">If the URL supports range requests you can limit bytes. Set the URL to your cloud object (S3/GCS/Azure Blob) to test throughput.</small>
  </div>

  <div class="card">
    <h2>3) Upload Speed</h2>
    <label>Upload endpoint (POST):</label>
    <input id="uploadUrl" type="url" value="https://httpbin.org/post" />
    <label>Upload size (MB):</label>
    <input id="uploadSize" type="text" value="5" />
    <button id="uploadBtn">Run upload test</button>
    <div id="uploadResults" class="result">No results yet.</div>
    <small class="note">Use your cloud API endpoint that accepts file uploads to measure ingress speed. CORS must allow requests from this page.</small>
  </div>

  <div class="card">
    <h2>4) POST JSON Echo Test</h2>
    <label>Echo endpoint (POST):</label>
    <input id="echoUrl" type="url" value="https://httpbin.org/post" />
    <label>JSON to send:</label>
    <textarea id="jsonPayload" rows="4">{ "test": "cloud-practical", "time": "" }</textarea>
    <button id="echoBtn">Send JSON</button>
    <div id="echoResults" class="result">No results yet.</div>
  </div>

  <div class="card">
    <h2>5) WebSocket Test</h2>
    <label>WebSocket URL (wss://):</label>
    <input id="wsUrl" type="text" value="wss://echo.websocket.events/" />
    <button id="wsConnectBtn">Connect</button>
    <button id="wsSendBtn" disabled>Send test message</button>
    <button id="wsCloseBtn" disabled>Close</button>
    <div id="wsResults" class="result">Not connected.</div>
    <small class="note">Use a WebSocket echo endpoint (or your server). If using cloud-managed services, ensure proper auth/CORS/wss support.</small>
  </div>

<script>
  // Utility: log to element
  function show(elId, html) { document.getElementById(elId).innerHTML = html; }

  // 1) Ping (RTT)
  document.getElementById('pingBtn').addEventListener('click', async () => {
    const url = document.getElementById('pingUrl').value.trim();
    if (!url) return show('pingResults','Enter a URL.');
    const runs = 5;
    const times = [];
    show('pingResults','Running...');
    for (let i=0;i<runs;i++){
      const t0 = performance.now();
      try {
        const r = await fetch(url, {cache:'no-store', mode:'cors'});
        await r.text().catch(()=>{}); // consume body
        const t1 = performance.now();
        times.push(t1-t0);
      } catch(err) {
        times.push(null);
      }
    }
    const good = times.filter(x=>x!==null);
    const avg = good.length ? (good.reduce((a,b)=>a+b,0)/good.length).toFixed(2) : 'N/A';
    show('pingResults', `<strong>RTT samples (ms):</strong> ${times.map(t=>t===null?'err':t.toFixed(2)).join(', ')}<br><strong>Average (ms):</strong> ${avg}`);
  });

  // 2) Download speed
  async function measureDownload(url, maxBytes) {
    const t0 = performance.now();
    const resp = await fetch(url, {cache:'no-store', mode:'cors'});
    if (!resp.ok) throw new Error('HTTP '+resp.status);
    const reader = resp.body.getReader();
    let bytes = 0;
    while(true){
      const {done, value} = await reader.read();
      if (done) break;
      bytes += value.length;
      if (bytes >= maxBytes) { // stop early
        reader.cancel(); break;
      }
    }
    const t1 = performance.now();
    return {bytes, ms: t1-t0};
  }
  document.getElementById('downloadBtn').addEventListener('click', async () => {
    const url = document.getElementById('downloadUrl').value.trim();
    const max = parseInt(document.getElementById('downloadBytes').value) || 5000000;
    show('downloadResults','Running download...');
    try {
      const r = await measureDownload(url, max);
      const mb = (r.bytes / (1024*1024));
      const secs = r.ms/1000;
      const mbps = (mb / secs * 8).toFixed(2);
      show('downloadResults', `Downloaded ${r.bytes} bytes (${mb.toFixed(2)} MB) in ${secs.toFixed(2)} s — ~${mbps} Mbps`);
    } catch(e){
      show('downloadResults','Error: '+e.message);
    }
  });

  // 3) Upload speed (generate blob client-side and POST)
  document.getElementById('uploadBtn').addEventListener('click', async () => {
    const url = document.getElementById('uploadUrl').value.trim();
    const mb = Math.max(0.5, parseFloat(document.getElementById('uploadSize').value) || 1);
    show('uploadResults', 'Preparing upload...');
    // Create a random blob of given size
    const size = Math.round(mb * 1024 * 1024);
    // fill with zeros to keep memory reasonable: use Uint8Array
    const chunk = new Uint8Array(1024*256); // 256KB chunk
    for (let i=0;i<chunk.length;i++) chunk[i]=Math.floor(Math.random()*256);
    const parts = [];
    let remaining = size;
    while(remaining>0) {
      const take = Math.min(remaining, chunk.length);
      parts.push(chunk.slice(0,take));
      remaining -= take;
    }
    const blob = new Blob(parts);
    try {
      const t0 = performance.now();
      const resp = await fetch(url, { method:'POST', body: blob, mode:'cors'});
      const t1 = performance.now();
      const ms = t1-t0;
      const secs = ms/1000;
      const mbSent = size/(1024*1024);
      const mbps = (mbSent / secs * 8).toFixed(2);
      const statusText = resp.ok ? `HTTP ${resp.status}` : `HTTP ${resp.status}`;
      show('uploadResults', `Uploaded ~${mbSent.toFixed(2)} MB in ${secs.toFixed(2)} s — ~${mbps} Mbps<br>${statusText}<br>Response size: ${resp.headers.get('content-length') || 'unknown'}`);
    } catch (err) {
      show('uploadResults', 'Error: ' + err.message + '<br>Note: CORS or server policy may block uploads from this page.');
    }
  });

  // 4) POST JSON echo
  document.getElementById('echoBtn').addEventListener('click', async () => {
    const url = document.getElementById('echoUrl').value.trim();
    const payloadElem = document.getElementById('jsonPayload');
    let payload;
    try { payload = JSON.parse(payloadElem.value); } catch(e){ return show('echoResults','Invalid JSON payload'); }
    payload.time = new Date().toISOString();
    show('echoResults','Sending...');
    try {
      const resp = await fetch(url, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload), mode:'cors' });
      const txt = await resp.text();
      show('echoResults', `<strong>HTTP ${resp.status}</strong><pre>${txt.substring(0,2000)}</pre>`);
    } catch (err) {
      show('echoResults','Error: ' + err.message + '<br>Make sure endpoint accepts JSON and allows CORS.');
    }
  });

  // 5) WebSocket test
  let ws;
  document.getElementById('wsConnectBtn').addEventListener('click', () => {
    const url = document.getElementById('wsUrl').value.trim();
    if (!url) return show('wsResults','Enter a WebSocket URL.');
    try {
      ws = new WebSocket(url);
    } catch(e) {
      return show('wsResults','WebSocket construction error: '+e.message);
    }
    show('wsResults','Connecting...');
    ws.onopen = () => {
      show('wsResults','Connected (ready).');
      document.getElementById('wsSendBtn').disabled = false;
      document.getElementById('wsCloseBtn').disabled = false;
    };
    ws.onmessage = (ev) => {
      show('wsResults', `Received: <pre>${ev.data}</pre>`);
    };
    ws.onerror = (ev) => {
      show('wsResults', 'WebSocket error (check console).');
      console.error(ev);
    };
    ws.onclose = (ev) => {
      show('wsResults', `Closed (code: ${ev.code})`);
      document.getElementById('wsSendBtn').disabled = true;
      document.getElementById('wsCloseBtn').disabled = true;
    };
  });

  document.getElementById('wsSendBtn').addEventListener('click', () => {
    if (!ws || ws.readyState !== WebSocket.OPEN) return show('wsResults','WebSocket not open.');
    const msg = {type:'test', ts:new Date().toISOString(), rand: Math.random().toString(36).slice(2,9)};
    ws.send(JSON.stringify(msg));
    show('wsResults', `Sent: <pre>${JSON.stringify(msg)}</pre>`);
  });

  document.getElementById('wsCloseBtn').addEventListener('click', () => {
    if (ws) ws.close();
  });
</script>
</body>
</html>
